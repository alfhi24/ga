# -*- coding: utf-8 -*-
"""Genithm.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nwk6JgyFvQsF2_Q32foSbnj0aRIAAfDJ
"""

# Commented out IPython magic to ensure Python compatibility.
from mpl_toolkits import mplot3d
# %matplotlib inline
import numpy as np
import matplotlib.pyplot as plt

ukpop = 20
gen = 16
pc = 0.5
pm = 0.5

# Define populasi awal
def generate_populasi(ukpop, gen) :
  populasi = []
  for i in range (ukpop) :
    populasi.append(np.random.randint(low=0, high=9, size=gen))

  return populasi
populasi = generate_populasi(ukpop, gen)

# for i in range (ukpop) :
#   print(populasi[i])

# phenotype
def phenotype(individu) :
  pembagi_x1 = 0
  pengali_x1 = 0
  pembagi_x2 = 0
  pengali_x2 = 0
  
  ra_x1 = 3
  rb_x1 = -3
  ra_x2 = 2
  rb_x2 = -2
  j = 1
  k = 1
  for i in range (len(individu)) :
    if (i < len(individu) / 2) :
      pengali_x1 += (individu[i] * (1 / np.power(10, j)))
      pembagi_x1 += (1 / np.power(2, j))
      j += 1
    else :
      pengali_x2 += (individu[i] * (1 / np.power(10, k)))
      pembagi_x2 += (1 / np.power(2, k))
      k += 1
  
  x1 = rb_x1 + ((ra_x1 - rb_x1) * pengali_x1 / pembagi_x1)
  x2 = rb_x2 + ((ra_x2 - rb_x2) * pengali_x2 / pembagi_x2)
  
  fen = []
  fen.append(x1)
  fen.append(x2)
  
  return fen

# for i in range (ukpop) :
#   print (phenotype(populasi[i]))

# Fitness
def fitness(individu) :
  a = 0.01
  f = 1 / (((4 - 2 * (phenotype(individu)[0] ** 2) + (phenotype(individu)[0] ** 4) / 3) * (phenotype(individu)[0] ** 2 + (phenotype(individu)[0] * phenotype(individu)[1]) + (-4 + 4 * (phenotype(individu)[1] ** 2)) * (phenotype(individu)[1] ** 2))) + a)
  return f

# for i in range (ukpop) :
#   print (fitness(populasi[i]))

# Total fitness
def total_fitness(populasi) :
  total = 0
  for i in range (len(populasi)) :
    total += fitness(populasi[i])
    
  return total

# print(total_fitness(populasi))

# Fitness terbesar
def max_fitness(populasi) :
  fit = []
  for i in range (len(populasi)) :
    fit.append(fitness(populasi[i]))
  max = 0
  for i in range(len(populasi)) :
    if (max < fit[i]) :
      max = fit[i]
  idx = fit.index(max)
  return populasi[idx]

# print(max_fitness(populasi))

# Rhoulette wheel
def RW (fitness, total_fitness) :
  val = fitness / total_fitness
  return val

# for i in range (ukpop) :
#   print(RW(fitness(populasi[i]), total_fitness(populasi)))

# Kumulatif dari RW
def CRW (populasi) :
  c = 0
  ar_c = []
  for i in range (len(populasi)) :
    c += RW(fitness(populasi[i]), total_fitness(populasi))
    ar_c.append(c)
  return ar_c

# for i in range (ukpop) :
#   print(CRW(populasi)[i])

# Parent selection
def parent_selection(populasi) :
  parent = []
  for i in range(len(populasi)) :
    ketemu = 'false'
    r = np.random.uniform(low = np.amin(CRW(populasi)), high = np.amax(CRW(populasi)))
    j = 0
    while ((ketemu != 'true') and (j < len(populasi))) :
      if (j == 0) :
        if (r <= CRW(populasi)[0]) :
          parent.append(populasi[0])
          ketemu = 'true'
      else :
        if (r <= CRW(populasi)[j] and r > CRW(populasi)[j-1]) :
          parent.append(populasi[j])
          ketemu = 'true'
      j += 1
  return parent

par = np.copy(parent_selection(populasi))

# Crossover
def crossover(individu1, individu2, pc) :
  anak = []
  anak1 = []
  anak2 = []
  titik = np.random.randint(1, len(individu1) - 1)
  p = np.random.uniform()
  if (p >= pc) :
    for j in range (len(individu1)) :
      if (j < titik) :
        anak1.append(individu2[j])
        anak2.append(individu1[j])
      else :
        anak1.append(individu1[j])
        anak2.append(individu2[j])
    anak.append(anak1)
    anak.append(anak2)
  else :
    for j in range (len(individu1)) :
      anak1.append(individu1[j])
      anak2.append(individu2[j])
    anak.append(anak1)
    anak.append(anak2)
  return anak

pos = 0
cross = []
i = 0
for i in range (ukpop//2) :
  cross.append(crossover(par[pos], par[pos+1], pc)[0])
  cross.append(crossover(par[pos], par[pos+1], pc)[1])
  pos += 2
# for j in range(ukpop) :
#   print(cross[j])

# Mutasi
def mutasi(cross, pm) :  
  ar_mut = np.copy(cross)
  for i in range (len(ar_mut)) :
    rm = np.random.randint(0,9)
    j = 0
    p = np.random.uniform()
    if (p >= pm) :
      for j in range(len(ar_mut[i])) :
        if (cross[i][j] == rm) :
          mut = np.random.randint(0,9)
          ar_mut[i][j] = mut
  return ar_mut

# for i in range (ukpop) :
#   print(mutasi(cross,pm)[i])

# General replacement
def replace(populasi, pm) :
  new_pop = []
  j = 0
  while (j < len(populasi)) :
    if (j == 0) :
      new_pop.append(max_fitness(populasi))
    else : 
      new_pop.append(mutasi(populasi,pm)[j])
    j += 1
  return new_pop

# for i in range(len(populasi)) :
#   print(replace(populasi,pm)[i])

# Driver
generasi = 100
old_gen = generate_populasi(ukpop, gen) 

fit_plot = []

for i in range(generasi) :
  new_gen = np.copy(replace(old_gen,pm))
  old_gen = np.copy(new_gen)
  new_gen = np.copy(replace(old_gen,pm))
  fit_plot.append(fitness(max_fitness(new_gen)))
  
individu_hasil = max_fitness(new_gen)
nilai = phenotype(individu_hasil)
x1 = nilai[0]
x2 = nilai[1]
print("(x1, x2) = ", nilai)
# hasil function
val = ((4 - 2 * (x1 ** 2) + (x1 ** 4) / 3) * (x1 ** 2 + (x1 * x2) + (-4 + 4 * (x2 ** 2)) * (x2 ** 2)))
print("f(x1, x2 ) = ", val)
plt.plot(fit_plot)
plt.show()

def f(x, y):
    return ((4 - 2 * (x ** 2) + (x ** 4) / 3) * (x ** 2 + (x * y) + (-4 + 4 * (y ** 2)) * (y ** 2)))
  
x = np.linspace(-3, 3, 50)
y = np.linspace(-2, 2, 50)
X, Y = np.meshgrid(x, y)
Z = f(X, Y)
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.contour3D(X, Y, Z, 1000, cmap='binary')
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_zlabel('z');